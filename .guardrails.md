# üö® GUARDRAILS: TUI Testing & Terminal Apps

**FOR LLM ASSISTANTS: These rules must be followed in every session. No exceptions.**

## Rule 1: NEVER Use `timeout` on TUI Applications

**Status**: MANDATORY - Violating this breaks developer terminal state

### The Rule
```
‚ùå FORBIDDEN:
timeout 5 bun run dev
timeout 10 npm start
timeout N <any-tui-app>
```

### Why
- TUI apps manage terminal "raw mode" for keyboard input
- `timeout` forcibly kills the process before cleanup runs
- This leaves the terminal broken: no input echo, no cursor visibility
- Developer must restart their shell to fix it

### The Only Correct Way
```typescript
// In code: Use Bun.spawn() + SIGINT only
const proc = Bun.spawn(["bun", "run", "dev"], {...});
process.kill(proc.pid, "SIGINT");  // Only this
```

```bash
# In CLI: Run and Ctrl+C manually
bun run dev
# User presses Ctrl+C
```

## Rule 2: Ctrl Event Loop with Proper Exit Handling

**Status**: IMPLEMENTED - Working correctly

### The Pattern
```typescript
// ‚úÖ CORRECT - Blocking while loop works with OpenTUI's event system
// OpenTUI's keyInput event handler keeps the process alive
// The while loop simply waits for the shouldExit flag
while (!shouldExit) {
  await new Promise(resolve => setTimeout(resolve, 100));
}

// Critical cleanup sequence:
// 1. Call renderer.destroy() to restore terminal state
// 2. Call process.exit(0) immediately after
// 3. NO setTimeout/race conditions in cleanup
```

### Implementation Location
File: `src/ui/renderer.tsx:500-516`

**Current working implementation:**
- Line 480-487: keyInput event handler sets `shouldExit` flag
- Line 500-502: Event loop waits for exit flag
- Line 504-516: Critical exit cleanup sequence
- Exit is clean: no terminal artifacts, shell prompt works correctly

## Rule 3: Test TUI Apps Only With Proper Event Loop Handling

**Status**: TECHNICAL - Tests must not use timeout

### Correct Test Pattern
```typescript
const proc = Bun.spawn(["bun", "run", "dev"], {
  stdout: "pipe",
  stderr: "pipe",
});

// Wait for initialization WITHOUT timeout
await new Promise(resolve => setTimeout(resolve, 3000));

// Check if still alive (no timeout command used)
const isAlive = !proc.exited;
expect(isAlive).toBe(true);

// EXIT ONLY WITH SIGINT
process.kill(proc.pid, "SIGINT");
await new Promise(resolve => setTimeout(resolve, 500));
```

### In bun test with Custom Timeouts
```typescript
// Set a reasonable timeout for the test itself, but don't use bash timeout
it("should run", async () => {
  // bun test will apply its default timeout
  // Inside, spawn + SIGINT only
  const proc = Bun.spawn(...);
  // ... test logic ...
  process.kill(proc.pid, "SIGINT");
}, { timeout: 30000 }); // bun test timeout, not bash timeout
```

## Rule 4: NEVER Run `bun ...` Commands Directly

**Status**: MANDATORY - Prevents accidental terminal state corruption

### The Rule
```
‚ùå FORBIDDEN:
bun run dev
bun test
bun run src/main.tsx
bun check
```

### Why
- Direct `bun` invocation can leave the TUI app running interactively
- If you forget to properly exit the app, the terminal gets stuck
- No way to clean up without user intervention (Ctrl+C)

### The Only Correct Way
```typescript
// In test code: Always spawn with Bun.spawn()
const proc = Bun.spawn(["bun", "run", "dev"], {
  stdout: "pipe",
  stderr: "pipe",
});
// ... run test logic ...
process.kill(proc.pid, "SIGINT");
```

### For Development / Manual Testing
- Only the USER should run `bun run dev` directly
- LLM should ONLY create tests that spawn processes, not run them directly

## Rule 5: Test Files Go in test/, Never in /tmp

**Status**: MANDATORY - Keeps codebase clean and organized

### The Rule
```
‚ùå FORBIDDEN:
/tmp/my-test.ts
/tmp/test-syntax.ts

‚úÖ CORRECT:
test/my-test.ts
test/integration/syntax.test.ts
```

### Why
- `/tmp` is cleaned up by the system, tests are lost
- Tests in `test/` are version-controlled and persistent
- Easier to organize and find tests later
- Integrates with bun test discovery

### Correct Pattern
```typescript
// Create test in test/syntax-highlighting.test.ts
import { describe, it, expect } from "bun:test";

describe("Syntax Highlighting", () => {
  it("should parse TypeScript", async () => {
    // Test code here
  });
});
```

### For Temporary Files During Tests
Use `bun.env.TMPDIR` or create in `test/fixtures/` instead:
```typescript
const testFile = `test/fixtures/temp-${Date.now()}.ts`;
// Use test file
// Clean up in afterAll hook
```

## Rule 6: Read These Files First Every Session

**Status**: NAVIGATION - These are the critical reference docs

1. **docs/ctrl-specific-constraints.md** (Section G.0) - TUI Testing rules
2. **docs/development-guide.md** (Section "Testing TUI Apps") - How to test properly
3. **docs/testing.md** (Section "Testing TUI Applications") - Detailed test examples
4. **.guardrails.md** (THIS FILE) - LLM-specific rules

## Checklist: Before Running Any Test

- [ ] Am I creating a test in `test/`, not `/tmp`? ‚Üí Always use `test/`
- [ ] Am I running `bun` commands via Bun.spawn in code, NOT directly? ‚Üí Never run bun directly
- [ ] Is this a TUI app (terminal UI using OpenTUI)? ‚Üí Apply TUI rules
- [ ] Am I using `timeout`, `kill -9`, or any force-kill? ‚Üí STOP, use SIGINT only
- [ ] Am I spawning with Bun.spawn? ‚Üí Yes, this is correct
- [ ] Am I sending SIGINT only to exit? ‚Üí Yes, this is correct
- [ ] Have I read the test examples in docs/testing.md? ‚Üí Reference them

## References

**Core Documentation (MUST READ):**
- CLAUDE.md - Project instructions (read first in every session)
- docs/ctrl-specific-constraints.md - Complete TUI constraints
- docs/development-guide.md - Development patterns
- docs/testing.md - Testing guidelines with examples

**Current Implementation:**
- src/ui/renderer.tsx - Event loop and exit cleanup (lines 480-516) ‚úÖ working
- test/tui.test.ts - Example tests using proper SIGINT handling
- src/main.tsx - App initialization
- src/config/watcher.ts - Config hot-reload with dual-mode watching ‚úÖ working

**OpenTUI References:**
- GitHub: https://github.com/anomalyco/opentui - Frame-based event loop
- GitHub: https://github.com/anomalyco/opencode - Real implementation example

## For Session Context

**Implementation Status: ‚úÖ COMPLETE**

The Ctrl event loop is working correctly:
- OpenTUI's keyInput event handler keeps the process alive
- The blocking while loop in renderer.tsx (lines 500-502) properly waits for exit
- Exit cleanup sequence (lines 504-516) restores terminal state cleanly
- No shell artifacts after exit, prompt works correctly

**Tests:**
- test/tui.test.ts: First test passes, verifies clean exit
- test/syntax-highlighting.test.ts: Syntax highlighting tests (all passing)
- Tests properly use SIGINT only (no timeout)
- Tests are created in test/ directory, not /tmp
- No broken renderer initialization issues to fix

**New Rules (Added Jan 23, 2026):**
- Rule 4: Never run `bun ...` commands directly - always spawn via Bun.spawn() in tests
- Rule 5: Always create tests in test/, never in /tmp
- These rules prevent terminal state corruption and keep codebase organized

---

**Last Updated:** January 23, 2026 (added Rules 4 & 5)
**Enforcement:** MANDATORY for all LLM sessions
**Violation Impact:**
- Rule 1: Breaks developer's terminal state
- Rule 4: Can corrupt TUI app state
- Rule 5: Loses test files to system cleanup

**Status Note:** Rule 2 event loop is working correctly. Rules 4 & 5 establish proper patterns for test creation and execution.
